/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Square from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Subscriptions {
    export interface Options {
        environment?: core.Supplier<environments.SquareEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the Square-Version header */
        version?: "2025-07-16";
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Square-Version header */
        version?: "2025-07-16";
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Subscriptions {
    protected readonly _options: Subscriptions.Options;

    constructor(_options: Subscriptions.Options = {}) {
        this._options = _options;
    }

    /**
     * Enrolls a customer in a subscription.
     *
     * If you provide a card on file in the request, Square charges the card for
     * the subscription. Otherwise, Square sends an invoice to the customer's email
     * address. The subscription starts immediately, unless the request includes
     * the optional `start_date`. Each individual subscription is associated with a particular location.
     *
     * For more information, see [Create a subscription](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#create-a-subscription).
     *
     * @param {Square.CreateSubscriptionRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.create({
     *         idempotency_key: "8193148c-9586-11e6-99f9-28cfe92138cf",
     *         location_id: "S8GWD5R9QB376",
     *         plan_variation_id: "6JHXF3B2CW3YKHDV4XEM674H",
     *         customer_id: "CHFGVKYY8RSV93M5KCYTG4PN0G",
     *         start_date: "2023-06-20",
     *         card_id: "ccof:qy5x8hHGYsgLrp4Q4GB",
     *         timezone: "America/Los_Angeles",
     *         source: {
     *             name: "My Application"
     *         },
     *         phases: [{
     *                 ordinal: BigInt("0"),
     *                 order_template_id: "U2NaowWxzXwpsZU697x7ZHOAnCNZY"
     *             }]
     *     })
     */
    public create(
        request: Square.CreateSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.CreateSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Square.CreateSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.CreateSubscriptionResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/subscriptions",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.CreateSubscriptionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling POST /v2/subscriptions.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Schedules a plan variation change for all active subscriptions under a given plan
     * variation. For more information, see [Swap Subscription Plan Variations](https://developer.squareup.com/docs/subscriptions-api/swap-plan-variations).
     *
     * @param {Square.BulkSwapPlanRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.bulkSwapPlan({
     *         new_plan_variation_id: "FQ7CDXXWSLUJRPM3GFJSJGZ7",
     *         old_plan_variation_id: "6JHXF3B2CW3YKHDV4XEM674H",
     *         location_id: "S8GWD5R9QB376"
     *     })
     */
    public bulkSwapPlan(
        request: Square.BulkSwapPlanRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.BulkSwapPlanResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bulkSwapPlan(request, requestOptions));
    }

    private async __bulkSwapPlan(
        request: Square.BulkSwapPlanRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.BulkSwapPlanResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/subscriptions/bulk-swap-plan",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.BulkSwapPlanResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/subscriptions/bulk-swap-plan.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Searches for subscriptions.
     *
     * Results are ordered chronologically by subscription creation date. If
     * the request specifies more than one location ID,
     * the endpoint orders the result
     * by location ID, and then by creation date within each location. If no locations are given
     * in the query, all locations are searched.
     *
     * You can also optionally specify `customer_ids` to search by customer.
     * If left unset, all customers
     * associated with the specified locations are returned.
     * If the request specifies customer IDs, the endpoint orders results
     * first by location, within location by customer ID, and within
     * customer by subscription creation date.
     *
     * @param {Square.SearchSubscriptionsRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.search({
     *         query: {
     *             filter: {
     *                 customer_ids: ["CHFGVKYY8RSV93M5KCYTG4PN0G"],
     *                 location_ids: ["S8GWD5R9QB376"],
     *                 source_names: ["My App"]
     *             }
     *         }
     *     })
     */
    public search(
        request: Square.SearchSubscriptionsRequest = {},
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.SearchSubscriptionsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__search(request, requestOptions));
    }

    private async __search(
        request: Square.SearchSubscriptionsRequest = {},
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.SearchSubscriptionsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/subscriptions/search",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.SearchSubscriptionsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling POST /v2/subscriptions/search.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a specific subscription.
     *
     * @param {Square.GetSubscriptionsRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.get({
     *         subscription_id: "subscription_id"
     *     })
     */
    public get(
        request: Square.GetSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.GetSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: Square.GetSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.GetSubscriptionResponse>> {
        const { subscription_id: subscriptionId, include } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (include !== undefined) {
            _queryParams["include"] = include;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.GetSubscriptionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling GET /v2/subscriptions/{subscription_id}.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates a subscription by modifying or clearing `subscription` field values.
     * To clear a field, set its value to `null`.
     *
     * @param {Square.UpdateSubscriptionRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.update({
     *         subscription_id: "subscription_id",
     *         subscription: {
     *             card_id: "{NEW CARD ID}"
     *         }
     *     })
     */
    public update(
        request: Square.UpdateSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.UpdateSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
    }

    private async __update(
        request: Square.UpdateSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.UpdateSubscriptionResponse>> {
        const { subscription_id: subscriptionId, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}`,
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.UpdateSubscriptionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling PUT /v2/subscriptions/{subscription_id}.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a scheduled action for a subscription.
     *
     * @param {Square.DeleteActionSubscriptionsRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.deleteAction({
     *         subscription_id: "subscription_id",
     *         action_id: "action_id"
     *     })
     */
    public deleteAction(
        request: Square.DeleteActionSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.DeleteSubscriptionActionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteAction(request, requestOptions));
    }

    private async __deleteAction(
        request: Square.DeleteActionSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.DeleteSubscriptionActionResponse>> {
        const { subscription_id: subscriptionId, action_id: actionId } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}/actions/${encodeURIComponent(actionId)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Square.DeleteSubscriptionActionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling DELETE /v2/subscriptions/{subscription_id}/actions/{action_id}.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Changes the [billing anchor date](https://developer.squareup.com/docs/subscriptions-api/subscription-billing#billing-dates)
     * for a subscription.
     *
     * @param {Square.ChangeBillingAnchorDateRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.changeBillingAnchorDate({
     *         subscription_id: "subscription_id",
     *         monthly_billing_anchor_date: 1
     *     })
     */
    public changeBillingAnchorDate(
        request: Square.ChangeBillingAnchorDateRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.ChangeBillingAnchorDateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__changeBillingAnchorDate(request, requestOptions));
    }

    private async __changeBillingAnchorDate(
        request: Square.ChangeBillingAnchorDateRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.ChangeBillingAnchorDateResponse>> {
        const { subscription_id: subscriptionId, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}/billing-anchor`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Square.ChangeBillingAnchorDateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/subscriptions/{subscription_id}/billing-anchor.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Schedules a `CANCEL` action to cancel an active subscription. This
     * sets the `canceled_date` field to the end of the active billing period. After this date,
     * the subscription status changes from ACTIVE to CANCELED.
     *
     * @param {Square.CancelSubscriptionsRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.cancel({
     *         subscription_id: "subscription_id"
     *     })
     */
    public cancel(
        request: Square.CancelSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.CancelSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__cancel(request, requestOptions));
    }

    private async __cancel(
        request: Square.CancelSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.CancelSubscriptionResponse>> {
        const { subscription_id: subscriptionId } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}/cancel`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.CancelSubscriptionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/subscriptions/{subscription_id}/cancel.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Lists all [events](https://developer.squareup.com/docs/subscriptions-api/actions-events) for a specific subscription.
     *
     * @param {Square.ListEventsSubscriptionsRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.listEvents({
     *         subscription_id: "subscription_id"
     *     })
     */
    public async listEvents(
        request: Square.ListEventsSubscriptionsRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.Page<Square.SubscriptionEvent>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: Square.ListEventsSubscriptionsRequest,
            ): Promise<core.WithRawResponse<Square.ListSubscriptionEventsResponse>> => {
                const { subscription_id: subscriptionId, cursor, limit } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (cursor !== undefined) {
                    _queryParams["cursor"] = cursor;
                }
                if (limit !== undefined) {
                    _queryParams["limit"] = limit?.toString() ?? null;
                }
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)) ??
                            environments.SquareEnvironment.Production,
                        `v2/subscriptions/${encodeURIComponent(subscriptionId)}/events`,
                    ),
                    method: "GET",
                    headers: mergeHeaders(
                        this._options?.headers,
                        mergeOnlyDefinedHeaders({
                            Authorization: await this._getAuthorizationHeader(),
                            "Square-Version": requestOptions?.version ?? "2025-07-16",
                        }),
                        requestOptions?.headers,
                    ),
                    queryParameters: _queryParams,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        data: _response.body as Square.ListSubscriptionEventsResponse,
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    throw new errors.SquareError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.SquareError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.SquareTimeoutError(
                            "Timeout exceeded when calling GET /v2/subscriptions/{subscription_id}/events.",
                        );
                    case "unknown":
                        throw new errors.SquareError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Pageable<Square.ListSubscriptionEventsResponse, Square.SubscriptionEvent>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) =>
                response?.cursor != null && !(typeof response?.cursor === "string" && response?.cursor === ""),
            getItems: (response) => response?.subscription_events ?? [],
            loadPage: (response) => {
                return list(core.setObjectProperty(request, "cursor", response?.cursor));
            },
        });
    }

    /**
     * Schedules a `PAUSE` action to pause an active subscription.
     *
     * @param {Square.PauseSubscriptionRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.pause({
     *         subscription_id: "subscription_id"
     *     })
     */
    public pause(
        request: Square.PauseSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.PauseSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__pause(request, requestOptions));
    }

    private async __pause(
        request: Square.PauseSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.PauseSubscriptionResponse>> {
        const { subscription_id: subscriptionId, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}/pause`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.PauseSubscriptionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/subscriptions/{subscription_id}/pause.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Schedules a `RESUME` action to resume a paused or a deactivated subscription.
     *
     * @param {Square.ResumeSubscriptionRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.resume({
     *         subscription_id: "subscription_id"
     *     })
     */
    public resume(
        request: Square.ResumeSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.ResumeSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__resume(request, requestOptions));
    }

    private async __resume(
        request: Square.ResumeSubscriptionRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.ResumeSubscriptionResponse>> {
        const { subscription_id: subscriptionId, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}/resume`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.ResumeSubscriptionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/subscriptions/{subscription_id}/resume.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Schedules a `SWAP_PLAN` action to swap a subscription plan variation in an existing subscription.
     * For more information, see [Swap Subscription Plan Variations](https://developer.squareup.com/docs/subscriptions-api/swap-plan-variations).
     *
     * @param {Square.SwapPlanRequest} request
     * @param {Subscriptions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.subscriptions.swapPlan({
     *         subscription_id: "subscription_id",
     *         new_plan_variation_id: "FQ7CDXXWSLUJRPM3GFJSJGZ7",
     *         phases: [{
     *                 ordinal: BigInt("0"),
     *                 order_template_id: "uhhnjH9osVv3shUADwaC0b3hNxQZY"
     *             }]
     *     })
     */
    public swapPlan(
        request: Square.SwapPlanRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): core.HttpResponsePromise<Square.SwapPlanResponse> {
        return core.HttpResponsePromise.fromPromise(this.__swapPlan(request, requestOptions));
    }

    private async __swapPlan(
        request: Square.SwapPlanRequest,
        requestOptions?: Subscriptions.RequestOptions,
    ): Promise<core.WithRawResponse<Square.SwapPlanResponse>> {
        const { subscription_id: subscriptionId, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/subscriptions/${encodeURIComponent(subscriptionId)}/swap-plan`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-07-16",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Square.SwapPlanResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/subscriptions/{subscription_id}/swap-plan.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = (await core.Supplier.get(this._options.token)) ?? process?.env["SQUARE_TOKEN"];
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
