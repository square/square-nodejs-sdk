/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Square from "../../../index";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers";
import * as serializers from "../../../../serialization/index";
import * as errors from "../../../../errors/index";
import { BreakTypes } from "../resources/breakTypes/client/Client";
import { EmployeeWages } from "../resources/employeeWages/client/Client";
import { Shifts } from "../resources/shifts/client/Client";
import { TeamMemberWages } from "../resources/teamMemberWages/client/Client";
import { WorkweekConfigs } from "../resources/workweekConfigs/client/Client";

export declare namespace Labor {
    export interface Options {
        environment?: core.Supplier<environments.SquareEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<core.BearerToken | undefined>;
        /** Override the Square-Version header */
        version?: "2025-08-20";
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Square-Version header */
        version?: "2025-08-20";
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Labor {
    protected readonly _options: Labor.Options;
    protected _breakTypes: BreakTypes | undefined;
    protected _employeeWages: EmployeeWages | undefined;
    protected _shifts: Shifts | undefined;
    protected _teamMemberWages: TeamMemberWages | undefined;
    protected _workweekConfigs: WorkweekConfigs | undefined;

    constructor(_options: Labor.Options = {}) {
        this._options = _options;
    }

    public get breakTypes(): BreakTypes {
        return (this._breakTypes ??= new BreakTypes(this._options));
    }

    public get employeeWages(): EmployeeWages {
        return (this._employeeWages ??= new EmployeeWages(this._options));
    }

    public get shifts(): Shifts {
        return (this._shifts ??= new Shifts(this._options));
    }

    public get teamMemberWages(): TeamMemberWages {
        return (this._teamMemberWages ??= new TeamMemberWages(this._options));
    }

    public get workweekConfigs(): WorkweekConfigs {
        return (this._workweekConfigs ??= new WorkweekConfigs(this._options));
    }

    /**
     * Creates a scheduled shift by providing draft shift details such as job ID,
     * team member assignment, and start and end times.
     *
     * The following `draft_shift_details` fields are required:
     * - `location_id`
     * - `job_id`
     * - `start_at`
     * - `end_at`
     *
     * @param {Square.CreateScheduledShiftRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.createScheduledShift({
     *         idempotencyKey: "HIDSNG5KS478L",
     *         scheduledShift: {
     *             draftShiftDetails: {
     *                 teamMemberId: "ormj0jJJZ5OZIzxrZYJI",
     *                 locationId: "PAA1RJZZKXBFG",
     *                 jobId: "FzbJAtt9qEWncK1BWgVCxQ6M",
     *                 startAt: "2019-01-25T03:11:00-05:00",
     *                 endAt: "2019-01-25T13:11:00-05:00",
     *                 notes: "Dont forget to prep the vegetables",
     *                 isDeleted: false
     *             }
     *         }
     *     })
     */
    public createScheduledShift(
        request: Square.CreateScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.CreateScheduledShiftResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createScheduledShift(request, requestOptions));
    }

    private async __createScheduledShift(
        request: Square.CreateScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.CreateScheduledShiftResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/labor/scheduled-shifts",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.CreateScheduledShiftRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.CreateScheduledShiftResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling POST /v2/labor/scheduled-shifts.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Publishes 1 - 100 scheduled shifts. This endpoint takes a map of individual publish
     * requests and returns a map of responses. When a scheduled shift is published, Square keeps
     * the `draft_shift_details` field as is and copies it to the `published_shift_details` field.
     *
     * The minimum `start_at` and maximum `end_at` timestamps of all shifts in a
     * `BulkPublishScheduledShifts` request must fall within a two-week period.
     *
     * @param {Square.BulkPublishScheduledShiftsRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.bulkPublishScheduledShifts({
     *         scheduledShifts: {
     *             "key": {}
     *         },
     *         scheduledShiftNotificationAudience: "AFFECTED"
     *     })
     */
    public bulkPublishScheduledShifts(
        request: Square.BulkPublishScheduledShiftsRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.BulkPublishScheduledShiftsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__bulkPublishScheduledShifts(request, requestOptions));
    }

    private async __bulkPublishScheduledShifts(
        request: Square.BulkPublishScheduledShiftsRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.BulkPublishScheduledShiftsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/labor/scheduled-shifts/bulk-publish",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.BulkPublishScheduledShiftsRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.BulkPublishScheduledShiftsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/labor/scheduled-shifts/bulk-publish.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns a paginated list of scheduled shifts, with optional filter and sort settings.
     * By default, results are sorted by `start_at` in ascending order.
     *
     * @param {Square.SearchScheduledShiftsRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.searchScheduledShifts({
     *         query: {
     *             filter: {
     *                 assignmentStatus: "ASSIGNED"
     *             },
     *             sort: {
     *                 field: "CREATED_AT",
     *                 order: "ASC"
     *             }
     *         },
     *         limit: 2,
     *         cursor: "xoxp-1234-5678-90123"
     *     })
     */
    public searchScheduledShifts(
        request: Square.SearchScheduledShiftsRequest = {},
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.SearchScheduledShiftsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__searchScheduledShifts(request, requestOptions));
    }

    private async __searchScheduledShifts(
        request: Square.SearchScheduledShiftsRequest = {},
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.SearchScheduledShiftsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/labor/scheduled-shifts/search",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.SearchScheduledShiftsRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.SearchScheduledShiftsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/labor/scheduled-shifts/search.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a scheduled shift by ID.
     *
     * @param {Square.RetrieveScheduledShiftRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.retrieveScheduledShift({
     *         id: "id"
     *     })
     */
    public retrieveScheduledShift(
        request: Square.RetrieveScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.RetrieveScheduledShiftResponse> {
        return core.HttpResponsePromise.fromPromise(this.__retrieveScheduledShift(request, requestOptions));
    }

    private async __retrieveScheduledShift(
        request: Square.RetrieveScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.RetrieveScheduledShiftResponse>> {
        const { id } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/labor/scheduled-shifts/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.RetrieveScheduledShiftResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling GET /v2/labor/scheduled-shifts/{id}.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates the draft shift details for a scheduled shift. This endpoint supports
     * sparse updates, so only new, changed, or removed fields are required in the request.
     * You must publish the shift to make updates public.
     *
     * You can make the following updates to `draft_shift_details`:
     * - Change the `location_id`, `job_id`, `start_at`, and `end_at` fields.
     * - Add, change, or clear the `team_member_id` and `notes` fields. To clear these fields,
     * set the value to null.
     * - Change the `is_deleted` field. To delete a scheduled shift, set `is_deleted` to true
     * and then publish the shift.
     *
     * @param {Square.UpdateScheduledShiftRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.updateScheduledShift({
     *         id: "id",
     *         scheduledShift: {
     *             draftShiftDetails: {
     *                 teamMemberId: "ormj0jJJZ5OZIzxrZYJI",
     *                 locationId: "PAA1RJZZKXBFG",
     *                 jobId: "FzbJAtt9qEWncK1BWgVCxQ6M",
     *                 startAt: "2019-03-25T03:11:00-05:00",
     *                 endAt: "2019-03-25T13:18:00-05:00",
     *                 notes: "Dont forget to prep the vegetables",
     *                 isDeleted: false
     *             },
     *             version: 1
     *         }
     *     })
     */
    public updateScheduledShift(
        request: Square.UpdateScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.UpdateScheduledShiftResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateScheduledShift(request, requestOptions));
    }

    private async __updateScheduledShift(
        request: Square.UpdateScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.UpdateScheduledShiftResponse>> {
        const { id, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/labor/scheduled-shifts/${encodeURIComponent(id)}`,
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.UpdateScheduledShiftRequest.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.UpdateScheduledShiftResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling PUT /v2/labor/scheduled-shifts/{id}.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Publishes a scheduled shift. When a scheduled shift is published, Square keeps the
     * `draft_shift_details` field as is and copies it to the `published_shift_details` field.
     *
     * @param {Square.PublishScheduledShiftRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.publishScheduledShift({
     *         id: "id",
     *         idempotencyKey: "HIDSNG5KS478L",
     *         version: 2,
     *         scheduledShiftNotificationAudience: "ALL"
     *     })
     */
    public publishScheduledShift(
        request: Square.PublishScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.PublishScheduledShiftResponse> {
        return core.HttpResponsePromise.fromPromise(this.__publishScheduledShift(request, requestOptions));
    }

    private async __publishScheduledShift(
        request: Square.PublishScheduledShiftRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.PublishScheduledShiftResponse>> {
        const { id, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/labor/scheduled-shifts/${encodeURIComponent(id)}/publish`,
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.PublishScheduledShiftRequest.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.PublishScheduledShiftResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError(
                    "Timeout exceeded when calling POST /v2/labor/scheduled-shifts/{id}/publish.",
                );
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a new `Timecard`.
     *
     * A `Timecard` represents a complete workday for a single team member.
     * You must provide the following values in your request to this
     * endpoint:
     *
     * - `location_id`
     * - `team_member_id`
     * - `start_at`
     *
     * An attempt to create a new `Timecard` can result in a `BAD_REQUEST` error when:
     * - The `status` of the new `Timecard` is `OPEN` and the team member has another
     * timecard with an `OPEN` status.
     * - The `start_at` date is in the future.
     * - The `start_at` or `end_at` date overlaps another timecard for the same team member.
     * - The `Break` instances are set in the request and a break `start_at`
     * is before the `Timecard.start_at`, a break `end_at` is after
     * the `Timecard.end_at`, or both.
     *
     * @param {Square.CreateTimecardRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.createTimecard({
     *         idempotencyKey: "HIDSNG5KS478L",
     *         timecard: {
     *             locationId: "PAA1RJZZKXBFG",
     *             startAt: "2019-01-25T03:11:00-05:00",
     *             endAt: "2019-01-25T13:11:00-05:00",
     *             wage: {
     *                 title: "Barista",
     *                 hourlyRate: {
     *                     amount: BigInt("1100"),
     *                     currency: "USD"
     *                 },
     *                 tipEligible: true
     *             },
     *             breaks: [{
     *                     startAt: "2019-01-25T06:11:00-05:00",
     *                     endAt: "2019-01-25T06:16:00-05:00",
     *                     breakTypeId: "REGS1EQR1TPZ5",
     *                     name: "Tea Break",
     *                     expectedDuration: "PT5M",
     *                     isPaid: true
     *                 }],
     *             teamMemberId: "ormj0jJJZ5OZIzxrZYJI",
     *             declaredCashTipMoney: {
     *                 amount: BigInt("500"),
     *                 currency: "USD"
     *             }
     *         }
     *     })
     */
    public createTimecard(
        request: Square.CreateTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.CreateTimecardResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createTimecard(request, requestOptions));
    }

    private async __createTimecard(
        request: Square.CreateTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.CreateTimecardResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/labor/timecards",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.CreateTimecardRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.CreateTimecardResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling POST /v2/labor/timecards.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns a paginated list of `Timecard` records for a business.
     * The list to be returned can be filtered by:
     * - Location IDs
     * - Team member IDs
     * - Timecard status (`OPEN` or `CLOSED`)
     * - Timecard start
     * - Timecard end
     * - Workday details
     *
     * The list can be sorted by:
     * - `START_AT`
     * - `END_AT`
     * - `CREATED_AT`
     * - `UPDATED_AT`
     *
     * @param {Square.SearchTimecardsRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.searchTimecards({
     *         query: {
     *             filter: {
     *                 workday: {
     *                     dateRange: {
     *                         startDate: "2019-01-20",
     *                         endDate: "2019-02-03"
     *                     },
     *                     matchTimecardsBy: "START_AT",
     *                     defaultTimezone: "America/Los_Angeles"
     *                 }
     *             }
     *         },
     *         limit: 100
     *     })
     */
    public searchTimecards(
        request: Square.SearchTimecardsRequest = {},
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.SearchTimecardsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__searchTimecards(request, requestOptions));
    }

    private async __searchTimecards(
        request: Square.SearchTimecardsRequest = {},
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.SearchTimecardsResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/labor/timecards/search",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.SearchTimecardsRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.SearchTimecardsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling POST /v2/labor/timecards/search.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns a single `Timecard` specified by `id`.
     *
     * @param {Square.RetrieveTimecardRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.retrieveTimecard({
     *         id: "id"
     *     })
     */
    public retrieveTimecard(
        request: Square.RetrieveTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.RetrieveTimecardResponse> {
        return core.HttpResponsePromise.fromPromise(this.__retrieveTimecard(request, requestOptions));
    }

    private async __retrieveTimecard(
        request: Square.RetrieveTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.RetrieveTimecardResponse>> {
        const { id } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/labor/timecards/${encodeURIComponent(id)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.RetrieveTimecardResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling GET /v2/labor/timecards/{id}.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates an existing `Timecard`.
     *
     * When adding a `Break` to a `Timecard`, any earlier `Break` instances in the `Timecard` have
     * the `end_at` property set to a valid RFC-3339 datetime string.
     *
     * When closing a `Timecard`, all `Break` instances in the `Timecard` must be complete with `end_at`
     * set on each `Break`.
     *
     * @param {Square.UpdateTimecardRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.updateTimecard({
     *         id: "id",
     *         timecard: {
     *             locationId: "PAA1RJZZKXBFG",
     *             startAt: "2019-01-25T03:11:00-05:00",
     *             endAt: "2019-01-25T13:11:00-05:00",
     *             wage: {
     *                 title: "Bartender",
     *                 hourlyRate: {
     *                     amount: BigInt("1500"),
     *                     currency: "USD"
     *                 },
     *                 tipEligible: true
     *             },
     *             breaks: [{
     *                     id: "X7GAQYVVRRG6P",
     *                     startAt: "2019-01-25T06:11:00-05:00",
     *                     endAt: "2019-01-25T06:16:00-05:00",
     *                     breakTypeId: "REGS1EQR1TPZ5",
     *                     name: "Tea Break",
     *                     expectedDuration: "PT5M",
     *                     isPaid: true
     *                 }],
     *             status: "CLOSED",
     *             version: 1,
     *             teamMemberId: "ormj0jJJZ5OZIzxrZYJI",
     *             declaredCashTipMoney: {
     *                 amount: BigInt("500"),
     *                 currency: "USD"
     *             }
     *         }
     *     })
     */
    public updateTimecard(
        request: Square.UpdateTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.UpdateTimecardResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateTimecard(request, requestOptions));
    }

    private async __updateTimecard(
        request: Square.UpdateTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.UpdateTimecardResponse>> {
        const { id, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/labor/timecards/${encodeURIComponent(id)}`,
            ),
            method: "PUT",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: serializers.UpdateTimecardRequest.jsonOrThrow(_body, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.UpdateTimecardResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling PUT /v2/labor/timecards/{id}.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a `Timecard`.
     *
     * @param {Square.DeleteTimecardRequest} request
     * @param {Labor.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.labor.deleteTimecard({
     *         id: "id"
     *     })
     */
    public deleteTimecard(
        request: Square.DeleteTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): core.HttpResponsePromise<Square.DeleteTimecardResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteTimecard(request, requestOptions));
    }

    private async __deleteTimecard(
        request: Square.DeleteTimecardRequest,
        requestOptions?: Labor.RequestOptions,
    ): Promise<core.WithRawResponse<Square.DeleteTimecardResponse>> {
        const { id } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/labor/timecards/${encodeURIComponent(id)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({
                    Authorization: await this._getAuthorizationHeader(),
                    "Square-Version": requestOptions?.version ?? "2025-08-20",
                }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: serializers.DeleteTimecardResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SquareError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SquareTimeoutError("Timeout exceeded when calling DELETE /v2/labor/timecards/{id}.");
            case "unknown":
                throw new errors.SquareError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = (await core.Supplier.get(this._options.token)) ?? process?.env["SQUARE_TOKEN"];
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
