// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient";
import * as core from "../../../../../../core";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers";
import * as environments from "../../../../../../environments";
import { handleNonStatusCodeError } from "../../../../../../errors/handleNonStatusCodeError";
import * as errors from "../../../../../../errors/index";
import * as serializers from "../../../../../../serialization/index";
import type * as Square from "../../../../../index";

export declare namespace CheckoutsClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class CheckoutsClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<CheckoutsClient.Options>;

    constructor(options: CheckoutsClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Creates a Terminal checkout request and sends it to the specified device to take a payment
     * for the requested amount.
     *
     * @param {Square.terminal.CreateTerminalCheckoutRequest} request
     * @param {CheckoutsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.terminal.checkouts.create({
     *         idempotencyKey: "28a0c3bc-7839-11ea-bc55-0242ac130003",
     *         checkout: {
     *             amountMoney: {
     *                 amount: BigInt("2610"),
     *                 currency: "USD"
     *             },
     *             referenceId: "id11572",
     *             note: "A brief note",
     *             deviceOptions: {
     *                 deviceId: "dbb5d83a-7838-11ea-bc55-0242ac130003"
     *             }
     *         }
     *     })
     */
    public create(
        request: Square.terminal.CreateTerminalCheckoutRequest,
        requestOptions?: CheckoutsClient.RequestOptions,
    ): core.HttpResponsePromise<Square.CreateTerminalCheckoutResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Square.terminal.CreateTerminalCheckoutRequest,
        requestOptions?: CheckoutsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Square.CreateTerminalCheckoutResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Square-Version": requestOptions?.version ?? "2026-01-22" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/terminals/checkouts",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.terminal.CreateTerminalCheckoutRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.CreateTerminalCheckoutResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/terminals/checkouts");
    }

    /**
     * Returns a filtered list of Terminal checkout requests created by the application making the request. Only Terminal checkout requests created for the merchant scoped to the OAuth token are returned. Terminal checkout requests are available for 30 days.
     *
     * @param {Square.terminal.SearchTerminalCheckoutsRequest} request
     * @param {CheckoutsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.terminal.checkouts.search({
     *         query: {
     *             filter: {
     *                 status: "COMPLETED"
     *             }
     *         },
     *         limit: 2
     *     })
     */
    public search(
        request: Square.terminal.SearchTerminalCheckoutsRequest = {},
        requestOptions?: CheckoutsClient.RequestOptions,
    ): core.HttpResponsePromise<Square.SearchTerminalCheckoutsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__search(request, requestOptions));
    }

    private async __search(
        request: Square.terminal.SearchTerminalCheckoutsRequest = {},
        requestOptions?: CheckoutsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Square.SearchTerminalCheckoutsResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Square-Version": requestOptions?.version ?? "2026-01-22" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                "v2/terminals/checkouts/search",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: serializers.terminal.SearchTerminalCheckoutsRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
                omitUndefined: true,
            }),
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.SearchTerminalCheckoutsResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v2/terminals/checkouts/search",
        );
    }

    /**
     * Retrieves a Terminal checkout request by `checkout_id`. Terminal checkout requests are available for 30 days.
     *
     * @param {Square.terminal.GetCheckoutsRequest} request
     * @param {CheckoutsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.terminal.checkouts.get({
     *         checkoutId: "checkout_id"
     *     })
     */
    public get(
        request: Square.terminal.GetCheckoutsRequest,
        requestOptions?: CheckoutsClient.RequestOptions,
    ): core.HttpResponsePromise<Square.GetTerminalCheckoutResponse> {
        return core.HttpResponsePromise.fromPromise(this.__get(request, requestOptions));
    }

    private async __get(
        request: Square.terminal.GetCheckoutsRequest,
        requestOptions?: CheckoutsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Square.GetTerminalCheckoutResponse>> {
        const { checkoutId } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Square-Version": requestOptions?.version ?? "2026-01-22" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/terminals/checkouts/${core.url.encodePathParam(checkoutId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.GetTerminalCheckoutResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/v2/terminals/checkouts/{checkout_id}",
        );
    }

    /**
     * Cancels a Terminal checkout request if the status of the request permits it.
     *
     * @param {Square.terminal.CancelCheckoutsRequest} request
     * @param {CheckoutsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.terminal.checkouts.cancel({
     *         checkoutId: "checkout_id"
     *     })
     */
    public cancel(
        request: Square.terminal.CancelCheckoutsRequest,
        requestOptions?: CheckoutsClient.RequestOptions,
    ): core.HttpResponsePromise<Square.CancelTerminalCheckoutResponse> {
        return core.HttpResponsePromise.fromPromise(this.__cancel(request, requestOptions));
    }

    private async __cancel(
        request: Square.terminal.CancelCheckoutsRequest,
        requestOptions?: CheckoutsClient.RequestOptions,
    ): Promise<core.WithRawResponse<Square.CancelTerminalCheckoutResponse>> {
        const { checkoutId } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ "Square-Version": requestOptions?.version ?? "2026-01-22" }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SquareEnvironment.Production,
                `v2/terminals/checkouts/${core.url.encodePathParam(checkoutId)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: serializers.CancelTerminalCheckoutResponse.parseOrThrow(_response.body, {
                    unrecognizedObjectKeys: "passthrough",
                    allowUnrecognizedUnionMembers: true,
                    allowUnrecognizedEnumValues: true,
                    skipValidation: true,
                    breadcrumbsPrefix: ["response"],
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.SquareError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v2/terminals/checkouts/{checkout_id}/cancel",
        );
    }
}
