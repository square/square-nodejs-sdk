import { array, lazy, object, optional, Schema, string } from '../schema';
import { Address, addressSchema } from './address';
import { Refund, refundSchema } from './refund';
import { Tender, tenderSchema } from './tender';

/**
 * Represents a transaction processed with Square, either with the
 * Connect API or with Square Point of Sale.
 * The `tenders` field of this object lists all methods of payment used to pay in
 * the transaction.
 */
export interface Transaction {
  /** The transaction's unique ID, issued by Square payments servers. */
  id?: string;
  /** The ID of the transaction's associated location. */
  locationId?: string;
  /** The timestamp for when the transaction was created, in RFC 3339 format. */
  createdAt?: string;
  /** The tenders used to pay in the transaction. */
  tenders?: Tender[];
  /** Refunds that have been applied to any tender in the transaction. */
  refunds?: Refund[];
  /**
   * If the transaction was created with the [Charge]($e/Transactions/Charge)
   * endpoint, this value is the same as the value provided for the `reference_id`
   * parameter in the request to that endpoint. Otherwise, it is not set.
   */
  referenceId?: string;
  /** Indicates the Square product used to process a transaction. */
  product?: string;
  /**
   * If the transaction was created in the Square Point of Sale app, this value
   * is the ID generated for the transaction by Square Point of Sale.
   * This ID has no relationship to the transaction's canonical `id`, which is
   * generated by Square's backend servers. This value is generated for bookkeeping
   * purposes, in case the transaction cannot immediately be completed (for example,
   * if the transaction is processed in offline mode).
   * It is not currently possible with the Connect API to perform a transaction
   * lookup by this value.
   */
  clientId?: string;
  /**
   * Represents a postal address in a country. The address format is based
   * on an [open-source library from Google](https://github.com/google/libaddressinput). For more information,
   * see [AddressValidationMetadata](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata).
   * This format has dedicated fields for four address components: postal code,
   * locality (city), administrative district (state, prefecture, or province), and
   * sublocality (town or village). These components have dedicated fields in the
   * `Address` object because software sometimes behaves differently based on them.
   * For example, sales tax software may charge different amounts of sales tax
   * based on the postal code, and some software is only available in
   * certain states due to compliance reasons.
   * For the remaining address components, the `Address` type provides the
   * `address_line_1` and `address_line_2` fields for free-form data entry.
   * These fields are free-form because the remaining address components have
   * too many variations around the world and typical software does not parse
   * these components. These fields enable users to enter anything they want.
   * Note that, in the current implementation, all other `Address` type fields are blank.
   * These include `address_line_3`, `sublocality_2`, `sublocality_3`,
   * `administrative_district_level_2`, `administrative_district_level_3`,
   * `first_name`, `last_name`, and `organization`.
   * When it comes to localization, the seller's language preferences
   * (see [Language preferences](https://developer.squareup.com/docs/locations-api#location-specific-and-seller-level-language-preferences))
   * are ignored for addresses. Even though Square products (such as Square Point of Sale
   * and the Seller Dashboard) mostly use a seller's language preference in
   * communication, when it comes to addresses, they will use English for a US address,
   * Japanese for an address in Japan, and so on.
   */
  shippingAddress?: Address;
  /** The order_id is an identifier for the order associated with this transaction, if any. */
  orderId?: string;
}

export const transactionSchema: Schema<Transaction> = object({
  id: ['id', optional(string())],
  locationId: ['location_id', optional(string())],
  createdAt: ['created_at', optional(string())],
  tenders: ['tenders', optional(array(lazy(() => tenderSchema)))],
  refunds: ['refunds', optional(array(lazy(() => refundSchema)))],
  referenceId: ['reference_id', optional(string())],
  product: ['product', optional(string())],
  clientId: ['client_id', optional(string())],
  shippingAddress: ['shipping_address', optional(lazy(() => addressSchema))],
  orderId: ['order_id', optional(string())],
});
