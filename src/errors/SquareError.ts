/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { toJson } from "../core/json";
import * as core from "../core";
import { Error_, ErrorCategory as GeneratedErrorCategory, ErrorCode as GeneratedErrorCode } from "../api";

const fallbackError = {
    category: "V1_ERROR",
    code: "Unknown",
} as SquareError.BodyError;

export class SquareError extends Error {
    readonly statusCode?: number;
    readonly body?: unknown;
    readonly errors: SquareError.BodyError[];
    public readonly rawResponse?: core.RawResponse;

    constructor({
        message,
        statusCode,
        body,
        rawResponse,
    }: {
        message?: string;
        statusCode?: number;
        body?: unknown;
        rawResponse?: core.RawResponse;
    }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, SquareError.prototype);
        this.statusCode = statusCode;
        this.rawResponse = rawResponse;
        this.body = body;
        if (body != null && typeof body === "object") {
            if ("errors" in body) {
                this.errors = (body as unknown as SquareErrorBody).errors ?? [fallbackError];
            } else {
                const v1Error = body as V1Error;
                this.errors = [
                    {
                        category: SquareError.ErrorCategory.V1Error,
                        code: v1Error.type ?? SquareError.ErrorCode.Unknown,
                        detail: v1Error.message,
                        field: v1Error.field,
                    },
                ];
            }
        } else {
            this.errors = [fallbackError];
        }
    }
}

function buildMessage({
    message,
    statusCode,
    body,
}: {
    message: string | undefined;
    statusCode: number | undefined;
    body: unknown | undefined;
}): string {
    let lines: string[] = [];
    if (message != null) {
        lines.push(message);
    }

    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }

    if (body != null) {
        lines.push(`Body: ${toJson(body, undefined, 2)}`);
    }

    return lines.join("\n");
}

export namespace SquareError {
    export type BodyError = {
        /**
         * The high-level category for the error.
         * See [ErrorCategory](#type-errorcategory) for possible values
         */
        category: ErrorCategory;
        /**
         * The specific code of the error.
         * See [ErrorCode](#type-errorcode) for possible values
         */
        code: ErrorCode;
    } & Omit<Error_, "category" | "code">;

    export type ErrorCategory = GeneratedErrorCategory | "V1_ERROR";
    export const ErrorCategory = {
        ...GeneratedErrorCategory,
        V1Error: "V1_ERROR",
    } as const;

    export type ErrorCode = GeneratedErrorCode | "Unknown" | string;
    export const ErrorCode = {
        ...GeneratedErrorCode,
        Unknown: "Unknown",
    } as const;
}

interface SquareErrorBody {
    errors?: SquareError.BodyError[];
}

interface V1Error {
    type?: string;
    message: string;
    field: string;
}